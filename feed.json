{
    "version": "https://jsonfeed.org/version/1",
    "title": "Портфолио на Калоян",
    "description": "",
    "home_page_url": "https://kaloyan-projects.github.io",
    "feed_url": "https://kaloyan-projects.github.io/feed.json",
    "user_comment": "",
    "icon": "https://kaloyan-projects.github.io/media/website/logo-2.svg",
    "author": {
        "name": "Калоян"
    },
    "items": [
        {
            "id": "https://kaloyan-projects.github.io/blender-geometry-nodes/",
            "url": "https://kaloyan-projects.github.io/blender-geometry-nodes/",
            "title": "Геометрични нодове в Blender",
            "summary": "Какво са Geometry Nodes? Geometry nodes (геометрични нодове) са чудесен начин да&hellip;",
            "content_html": "<h1>Какво са Geometry Nodes?</h1>\n<p>Geometry nodes (геометрични нодове) са чудесен начин да изменим геометрията на обект, но по обратим начин. Това означава, че може да се върнем на всяка стъпка от редакцията и да правим промени.</p>\n<h3>Обратими промени</h3>\n<p>Ако, например, искаме да заоблим ръбовете на обект, може да го направим с Ctrl+B и да приложим промените, но после единственият начин да ги отменим е да се върнем назад с Ctrl+Z, като трябва да отменим и всички други промени, направени след това. Ако вместо това използваме модификатор, тогава може да го включваме и изключваме по всяко време. Blender разполага с множество полезни модификатори, които променят формата на геометрията, създават нова или заличават съществуваща. Може да се каже, че Geometry Nodes ни позволява да си правим собствени модификатори.</p>\n<h3>Изменение на формата на обекти с нодове</h3>\n<p>Има и много неща, които не биха били възможни без Geometry Nodes. Например, нека анимираме стълбова диаграма със случайни стойности.</p>\n<p>Да започнем като направим единичен стълб. Той ще бъде обикновено кубче, като центърът му ще бъде изместен долу, за да може при промяна на височината да се вдига само нагоре.</p>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://kaloyan-projects.github.io/media/posts/15/Snimka-ot-2024-10-03-12-02-35-2.png\" alt=\"\" width=\"1026\" height=\"468\"></figure>\n<p>После, нека да отидем в работното пространство \"Geometry Nodes\", и да създадем нова група от бутона \"New\". Тук ще добавим необходимите нодове, за да направим стълбова диаграма.</p>\n<p>Тъй като стълбовете ще са подредени един до един в линия, ще използваме нода \"Mesh Line\". В \"Mode\" ще изберем \"End Points\" и ще определим начална и крайна точка на линията. Може да зададем броя точки да е 40. После ще инстанцираме (ще направим копие на) стълба на всяка една от точките, тоест, ще имаме 40 стълба. За това ще ползваме \"Instance on points\" нода. За да имат случайна височина, ще използваме \"Noise Texture\" нод, който ще мине през Z координата на \"Combine XYZ\" нод (за да контролира само височината Z) преди да се свърже със \"Scale\" входа на Instance on Points\" нода. За да имаме по-драматични промени във височината, може да добавим \"Map Range\" нод и да променим минималните и максимални стойности. За да анимираме диаграмата да се движи в някоя посока, може да добавим стойност към X координата на вектора на Noise текстурата. Така че ще ни трябват нодовете \"Position\" (за текущата позиция) и \"Vector Math\" (за да добавим към нея), които ще свържем към входа \"Vector\" на Noise текстурата. Във полето за X координата на \"Vector Math\" нода може да създадем драйвер, като напишем \"<em><strong>#frame / 50</strong></em>\", което ще зададе X координата да е равен на текущия кадър от анимацията, разделен на 50 (за да е по-бавна анимацията). Това ще даде движение на стълбовете.</p>\n<p>Накрая връзките ни трябва да изглеждат по следния начин:</p>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://kaloyan-projects.github.io/media/posts/15/Snimka-ot-2024-10-03-12-18-32.png\" alt=\"\" width=\"1176\" height=\"518\"></figure>\n<p>А резултатът от тези връзки трябва да изглежда така:</p>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://kaloyan-projects.github.io/media/posts/15/Snimka-ot-2024-10-03-12-25-25.png\" alt=\"\" width=\"1124\" height=\"447\"></figure>\n<p>Ето как можем да направим стълбова диаграма с Geometry Nodes (геометрични нодове). Най-хубавото е, че можем да видим нагледно какво направи нашата група от нодове. Това е много прост пример, има много по-големи възможности, особено след добавянето на Node Tools в Blender 4.0, които позволяват да работим според селекцията и позицията на курсора в 3D пространството.</p>\n<p>След като добавим цветен материал, нагласим контраста и още някой композиционен ефект получаваме задоволителен резултат:</p>\n<p><video loading=\"lazy\" width=\"600\" height=\"300\" controls=\"controls\" data-mce-fragment=\"1\">\n<source src=\"../media/files/column-animation.mp4\" type=\"video/mp4\" /></video></p>",
            "image": "https://kaloyan-projects.github.io/media/posts/15/post-thumbnail-6.png",
            "author": {
                "name": "Калоян"
            },
            "tags": [
                   "Урок",
                   "Blender",
                   "3D"
            ],
            "date_published": "2024-10-03T11:41:20+03:00",
            "date_modified": "2024-10-03T12:37:38+03:00"
        },
        {
            "id": "https://kaloyan-projects.github.io/subtitle-editing-embedding-and-extraction/",
            "url": "https://kaloyan-projects.github.io/subtitle-editing-embedding-and-extraction/",
            "title": "Вграждане, редакция и извличане на субтитри",
            "summary": "Субтитри! Не винаги разполагаме с дублаж, а и не винаги го предпочитаме,&hellip;",
            "content_html": "<p>Субтитри! Не винаги разполагаме с дублаж, а и не винаги го предпочитаме, затова понякога се налага да четем субтитри. Но ако няма, как може да си направим? А ако имат грешки и трябва да ги поправим? Нека да разгледаме.</p>\n<h1>Субтитрови формати</h1>\n<p>Има няколко преобладаващи формати при субтитрите, в зависимост от това, което целим с тях.</p>\n<h3>SRT</h3>\n<p>Този формат поддържа най-основно форматиране на текста, като позволява той да бъде наклонен, удебелен, подчетран и да се определи мястото му и шрифта му. SRT форматът запазва субтитрите по много прост начин. Започва с поредния им номер, на следващия ред – времето на появяване и скриване, и след това – самите субтитри. Изглежда по следния начин:</p>\n<pre class=\"language-markdown line-numbers\"><code>1\n00:00:27,533 --&gt; 00:00:28,766\nТова са първите субтитри\n\n2\n00:00:29,233 --&gt; 00:00:29,966\nТова са вторите субтитри\nи са на два реда\n\n3\n00:00:30,933 --&gt; 00:00:31,266\n&lt;i&gt;Тези субтитри са наклонени&lt;/i&gt;\n\n4\n00:00:32,533 --&gt; 00:00:34,433\n&lt;b&gt;А тези са удебелени&lt;/b&gt;</code></pre>\n<h3>ASS</h3>\n<p>ASS форматът поддържа по-сложно форматиране на субтитрите: могат да се анимират, оцветяват, подрязват с маска (която също може да се анимира), да се създават различни стилове и още. За да се възползвате напълно от възможностите на формата, трябва да можете повече от писане на текст. Някои автори даже анимират субтитрите да следват движението на обекти във видеото, за да се създаде илюзията, че текстът е част от самото видео.</p>\n<pre class=\"language-ini line-numbers\"><code>[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\nDialogue: 0,0:00:14.44,0:00:18.18,Default,,0,0,0,,{\\K34}След {\\K34}300 {\\K23}ме{\\K21}тра\nDialogue: 0,0:00:18.18,0:00:21.86,Default,,0,0,0,,{\\K16}За{\\K23}вий{\\K16}те {\\K13}на{\\K16}ля{\\K16}во\nDialogue: 0,0:00:21.86,0:00:25.59,Default,,0,0,0,,{\\kf28}Пос{\\kf24}ле\nDialogue: 0,0:00:25.59,0:00:29.90,Default,,0,0,0,,{\\K18}Ще {\\K66}пристигнете {\\K15}на {\\K92}местоназначението {\\K16}си</code></pre>\n<h1>Писане на субтитри</h1>\n<p>Има различни програми за редакция на субтитри. Ще разгледаме Aegisub, безплатна програма с отворен код. Има три главни части на интерфейса: Превюто на видеото, визуализация на аудиото и, най-отдолу, субтитрите. Може да избирате различен размер на превюто на видеото. За да се запазят промените над субтитрите, трябва да ги приложите. Вляво са инструментите за трансформация (местене, въртене, накланяне и подрязване) на субтитрите. Може да превъртате между кадрите със стрелките наляво и надясно. С <em><strong>Ctrl+3</strong></em> и <em><strong>Ctrl+4</strong></em> задавате началото или края на субтитрите на текущия кадър. Когато сте в аудио прозореца, ляв бутон на мишката задава началото на субтитрите, десен бутон – края, а среден бутон (колелцето) превърта до съответния момент в записа. Когато сме готови, можем да експортираме субтитрите в SRT, ASS, SUB и други формати.</p>\n<figure class=\"post__image\" ><img loading=\"lazy\" src=\"https://kaloyan-projects.github.io/media/posts/13/Snimka-ot-2024-10-02-18-10-31.png\" alt=\"\" width=\"1115\" height=\"563\">\n<figcaption >Редактиране на субтитри в Aegisub</figcaption>\n</figure>\n<p>Все пак не е необходимо да използваме специализирана програма, за да правим субтитри. Програми за видео редакция като Kdenlive също имат такава функционалност, макар и по-ограничена. Но ако искаме само да преведем реч, това е повече от достатъчно. Освен това, отскоро Kdenlive поддържа множество пътечки за субтитри. За да добавите субтитри, отидете в <em><strong>View &gt; Subtitles</strong></em>. Това ще отвори панела за субтитри, ако вече не е отворен. Оттам може да добавяте субтитри с \"+\" бутона. За да експортирате субтитрите, отидете в <em><strong>Project &gt; Subtitles &gt; Export Subtitle File…</strong></em> С Kdenlive може да експортираме само SRT файл, но в много случаи това е достатъчно.</p>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://kaloyan-projects.github.io/media/posts/13/Snimka-ot-2024-10-02-18-03-08.png\" alt=\"\" width=\"694\" height=\"460\"><figcaption>Редактиране на субтитри в Kdenlive</figcaption></figure>\n<h1>Начини на вграждане на субтитри</h1>\n<p>Субтитрите ни са готови, но ако искаме да ги видим, трябва всеки път да ги избираме ръчно. Щеше да е много по-лесно ако вече имаше пътечка със субтитри в самото видео. Един видео контейнер е комбинация от различни данни: може да съдържа множество видео пътечки, аудио пътечки и пътечки за субтитри. Ако добавим субтитрите директно в контейнера, няма да има нужда да ги избираме ръчно при отваряне на видеото.</p>\n<p>За да го постигнем, можем да ползваме програма като HandBrake, или даже инструменти за командния ред като FFmpeg. В HandBrake можем просто да изберем \"Отвори източник\" и после да отидем в Субтитри &gt; Tracks &gt; Add New Track. Оттам избираме език, кодировка на текста и файл, от който да бъдат заредени.</p>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://kaloyan-projects.github.io/media/posts/13/Snimka-ot-2024-10-02-18-45-45.png\" alt=\"\" width=\"1075\" height=\"528\"><figcaption>Вграждане на субтитри с HandBrake</figcaption></figure>\n<p>С FFmpeg можем да използваме следната команда:</p>\n<pre class=\"language-bash line-numbers\"><code>ffmpeg -i my_video.mp4 -i subtitles.srt -c copy -c:s mov_text my_video_with_subtitles.mp4</code></pre>\n<p>Можем да добавим информация за езика на субтитрите ако уточним:</p>\n<pre class=\"language-bash line-numbers\"><code>ffmpeg -i my_video.mp4 -i subtitles.srt -c:a copy -c:v copy -c:s mov_text -metadata:s:s:0 language=bul my_video_with_subtitles.mp4</code></pre>\n<p>Има и втори начин на вграждане, при който субтитрите се растеризират и стават неотделима част от видеото – тогава не могат да се изключат. Може да се използва само когато няма да превеждаме видеото и на други езици. За да го направим в Kdenlive, просто трябва да оставим пътечката за субтитри видима при експортиране на видеото. Тогава те ще останат видими при рендериране. С HandBrake може да отметнем кутийката \"Burn into video\" когато добавяме пътечка. А с FFmpeg ползваме следната команда:</p>\n<pre class=\"language-bash line-numbers\"><code>ffmpeg -i my_video.mp4 -vf \"subtitles=subtitles.srt\" my_video_with_subtitles.mp4</code></pre>\n<h1>Извличане на субтитри от видео</h1>\n<p>С FFmpeg може да извлечем субтитри от видеото със следната команда:</p>\n<pre class=\"language-bash line-numbers\"><code>ffmpeg -i video_with_subtitles.mp4 -map 0:s:0 subtitles.srt</code></pre>\n<p>След това може да отворим файла и да го редактираме с Aegisub или друга програма, както е показано по-горе.</p>\n<p> </p>",
            "image": "https://kaloyan-projects.github.io/media/posts/13/post-thumbnail-5.png",
            "author": {
                "name": "Калоян"
            },
            "tags": [
                   "Субтитри",
                   "Превод",
                   "Езици",
                   "Видео редакция",
                   "Kdenlive",
                   "HandBrake"
            ],
            "date_published": "2024-10-02T17:03:41+03:00",
            "date_modified": "2024-10-03T10:47:26+03:00"
        },
        {
            "id": "https://kaloyan-projects.github.io/raster-and-vector-graphics/",
            "url": "https://kaloyan-projects.github.io/raster-and-vector-graphics/",
            "title": "Растерни и векторни изображения",
            "summary": "Разлики между растери и вектори Когато искаме да представим нещо графично на&hellip;",
            "content_html": "<h1>Разлики между растери и вектори</h1>\n<p>Когато искаме да представим нещо графично на компютър, има два главни начина да го постигнем – векторно и растерно. Кое е по-подходящо зависи от това какво целим.</p>\n<p>Всички снимки, например, са растерни. Това означава, че са съставени от множество пиксели, съдържащи информация за цвят, обикновено в трите цветови канала – червено, зелено и синьо. При векторната графика, от друга страна, няма пиксели, а точки, криви и фигури.</p>\n<p>Предимството им е, че могат да бъдат преоразмерени без да загубят качеството си. Ако увеличим едно растерно изображение, ще видим съставните му пиксели и програмата за разглеждане може да се опита да ги скрие като ги замаже, но векторите остават ясни. Но колкото по-сложно е едно векторно изображение, толкова по-сложно става за визуализиране и манипулация. Затова те са по-подходящи за документи, елементи на потребителски интерфейс и изображения в минималистичен стил.</p>\n<h1>Растерни формати</h1>\n<h3>PNG</h3>\n<p>PNG е широко поддържан  растерен формат за изображения и двете му най-характерни черти са, че при него няма загуба на качество, и че поддържа прозрачност. Той е най-подходящ при принтиране, където загубата на качество на JPEG би навредила на резултата. Използвайте го, ако смятате да правите допълнителни промени по изображението по-късно, за да запазите качеството му.</p>\n<h3>JPG / JPEG</h3>\n<p>Когато снимате с телефон или фотоапарат, обикновено това е файловия формат на снимката. При повечето фотоапарати ще разполагате и с RAW файл, който е необработено изображение, с по-голям размер но по-подходящо за обработка, но това е друга тема. JPEG използва алгоритъм за да компресира снимката, но не прилага същото ниво на компресия навсякъде. Компресията е най-видима по ръбове и области с голям контраст.</p>\n<figure class=\"post__image\" ><figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://kaloyan-projects.github.io/media/posts/11/Snimka-ot-2024-10-01-10-46-03.png\" alt=\"\" width=\"426\" height=\"293\"></figure>\n<figcaption >Компресия със загуба на качество при JPEG</figcaption>\n</figure>\n<h1>Векторни формати</h1>\n<h3>SVG</h3>\n<p>SVG е стандартният векторен формат онлайн. Използва се и се поддържа навсякъде. Един файл съдържа обекти. Тези обекти могат да бъдат фигури, пътеки, текст или растер. Фигурите имат специални свойства като например брой страни, които могат да бъдат променяни, преди обекта да се превърне в пътека. Тогава той е съставен от точки и криви и с тях също може да се променя формата. И текстовите обекти могат да се променят свободно докато не бъдат превърнати в пътеки. Растерни изображения също може да се вграждат.</p>\n<figure class=\"post__image\" ><img loading=\"lazy\" src=\"https://kaloyan-projects.github.io/media/posts/11/Snimka-ot-2024-10-01-10-39-36.png\" alt=\"\" width=\"425\" height=\"269\">\n<figcaption >Редактиране на кривите на фигура в Inkscape</figcaption>\n</figure>",
            "image": "https://kaloyan-projects.github.io/media/posts/11/post-thumbnail-4.png",
            "author": {
                "name": "Калоян"
            },
            "tags": [
                   "Растерна графика",
                   "Векторна графика"
            ],
            "date_published": "2024-10-01T10:13:39+03:00",
            "date_modified": "2024-10-01T14:36:10+03:00"
        },
        {
            "id": "https://kaloyan-projects.github.io/8-linux-command-line-tools/",
            "url": "https://kaloyan-projects.github.io/8-linux-command-line-tools/",
            "title": "8 програми за командния ред на Линукс",
            "summary": "1. Uniutils Uniutils предоставя полезни команди за работа със знаци от Unicode.",
            "content_html": "<h3>1. Uniutils</h3>\n<p>Uniutils предоставя полезни команди за работа със знаци от Unicode. С този инструмент може да се провери числовата стойност на всеки знак, както е в Unicode таблицата, заедно с неговото име и кодировка или пък да проверим за честотата на знаците в даден текст. Пакетът може да се инсталира със следната команда на Ubuntu базирани дистрибуции:</p>\n<pre class=\"language-bash line-numbers\"><code>apt install uniutils</code></pre>\n<p>Една от командите, които Uniutils предоставя е <em><strong>uniname</strong></em>. Ето как може да я използваме, за да проверим информацията за следния текст:</p>\n<pre class=\"language-bash line-numbers\"><code>echo \"Текст.\" | uniname\n:'\nРезултат:\nNo LINES variable in environment so unable to determine lines per page.\nUsing default of 24.\ncharacter  byte       UTF-32   encoded as     glyph   name\n        0          0  000422   D0 A2          Т      CYRILLIC CAPITAL LETTER TE\n        1          2  000435   D0 B5          е      CYRILLIC SMALL LETTER IE\n        2          4  00043A   D0 BA          к      CYRILLIC SMALL LETTER KA\n        3          6  000441   D1 81          с      CYRILLIC SMALL LETTER ES\n        4          8  000442   D1 82          т      CYRILLIC SMALL LETTER TE\n        5         10  00002E   2E             .      FULL STOP\n        6         11  00000A   0A                     LINE FEED (LF)\n\n'</code></pre>\n<p>С друга команда, unihist, може да видим хистограма (честотата) на въведените символи във втората колона:</p>\n<pre class=\"language-bash line-numbers\"><code>echo 'Това изречение съдържа буквата \"а\" 7 пъти и буквата \"и\" 6 пъти' | unihist\n:'\nРезултат:\n\t  1,587\t       1\t0x00000A\n\t 17,460\t      11\t0x000020\n\t  6,349\t       4\t0x000027\t\"\n\t  1,587\t       1\t0x000036\t6\n\t  1,587\t       1\t0x000037\t7\n\t  1,587\t       1\t0x000422\tТ\n\t 11,111\t       7\t0x000430\tа\n\t  3,175\t       2\t0x000431\tб\n\t  4,762\t       3\t0x000432\tв\n\t  1,587\t       1\t0x000434\tд\n\t  4,762\t       3\t0x000435\tе\n\t  1,587\t       1\t0x000436\tж\n\t  1,587\t       1\t0x000437\tз\n\t  9,524\t       6\t0x000438\tи\n\t  3,175\t       2\t0x00043A\tк\n\t  1,587\t       1\t0x00043D\tн\n\t  1,587\t       1\t0x00043E\tо\n\t  3,175\t       2\t0x00043F\tп\n\t  3,175\t       2\t0x000440\tр\n\t  1,587\t       1\t0x000441\tс\n\t  6,349\t       4\t0x000442\tт\n\t  3,175\t       2\t0x000443\tу\n\t  1,587\t       1\t0x000447\tч\n\t  6,349\t       4\t0x00044A\tъ\n'</code></pre>\n<h3>2. Аsciinema</h3>\n<p>Asciinema позволява да се записват и възпроизвеждат терминалните сесии. Но не по традиционния начин за записване екрана – записите се запазват като <strong>cast</strong> файл, който съдържа информация за въведените команди, за да може да се възпроизведат по-късно. Това прави файловете много по-малки от обикновено видео. На дистрибуции на Ubuntu може да се инсталира с:</p>\n<pre class=\"language-bash line-numbers\"><code>apt install asciinema</code></pre>\n<p>Записи може да са направят с командата:</p>\n<pre class=\"language-bash line-numbers\"><code>asciinema rec filename.cast</code></pre>\n<p>И после да се възпроизвеждат така:</p>\n<pre class=\"language-bash line-numbers\"><code>asciinema play path/to/recording.cast</code></pre>\n<h3>3. Cava</h3>\n<p>Cava е по-графична от другите инструменти споменати тук, защото се използва за визуализиране на звук. Инсталира се с:</p>\n<pre class=\"language-bash line-numbers\"><code>sudo apt install cava</code></pre>\n<p>И е лесна за използване – стартира се с:</p>\n<pre class=\"language-bash line-numbers\"><code>cava</code></pre>\n<p>След изпълнение би трябвало да виждате бели стълбчета, отговарящи на силата на звука. Отворете аудио запис за да пробвате. Може да персонализирате цвета, броя и ширината на стълбчетата в config файла на cava, който обикновено се намира в <em><strong>~/.config/cava/config</strong></em></p>\n<h3>4. img2wav</h3>\n<p>Със img2wav може изображение да се превърне в звук – това става като се възпроизвеждат определени честоти, така че спектрограмата на аудиото да заприлича на изображението. Ефектът може да се види в Audacity, като се избере изглед на спектрограма. За инсталиране:</p>\n<pre class=\"language-bash line-numbers\"><code>apt install img2wav</code></pre>\n<p>После, за да генерирате wav файл:</p>\n<pre class=\"language-bash line-numbers\"><code>img2wav your-image.png</code></pre>\n<p>По този начин могат да се скриват съобщения в спектрограмата на аудио файлове.</p>\n<figure class=\"post__image\" ><img loading=\"lazy\" src=\"https://kaloyan-projects.github.io/media/posts/9/Snimka-ot-2024-09-30-13-23-30.png\" alt=\"\" width=\"1156\" height=\"523\">\n<figcaption >Скрито съобщение на спектрограма в Audacity</figcaption>\n</figure>\n<h3>5. ExifTool</h3>\n<p>ExifTool е апликация за редактиране на метаданни на различни типове файлове. Може да се инсталира с:</p>\n<pre class=\"language-bash line-numbers\"><code>apt install libimage-exiftool-perl</code></pre>\n<p>Ето примери как може да се ползва ExifTool:</p>\n<pre class=\"language-bash line-numbers\"><code># Добавяне на съобщение \"Здравей!\" в метаданните на PDF документ\nexiftool -Greeting=\"Здравей!\" document.pdf\n# Изписване на метаданните на mp3 файл\nexiftool --list audio.mp3\n\n# Примерен изход за изображение, редактирано с GIMP:\n:'\nExifTool Version Number         : 12.40\nFile Name                       : .face\nDirectory                       : .\nFile Size                       : 20 KiB\nFile Modification Date/Time     : 2023:05:14 10:06:35+03:00\nFile Access Date/Time           : 2024:09:29 19:52:35+03:00\nFile Inode Change Date/Time     : 2023:05:14 10:06:35+03:00\nFile Permissions                : -rw-r--r--\nFile Type                       : PNG\nFile Type Extension             : png\nMIME Type                       : image/png\nImage Width                     : 96\nImage Height                    : 96\nBit Depth                       : 8\nColor Type                      : RGB\nCompression                     : Deflate/Inflate\nFilter                          : Adaptive\nInterlace                       : Noninterlaced\nProfile Name                    : ICC Profile\nProfile CMM Type                : Little CMS\nProfile Version                 : 4.3.0\nProfile Class                   : Display Device Profile\nColor Space Data                : RGB\nProfile Connection Space        : XYZ\nProfile Date Time               : 2023:05:14 07:05:56\nProfile File Signature          : acsp\nPrimary Platform                : Apple Computer Inc.\nCMM Flags                       : Not Embedded, Independent\nDevice Manufacturer             : \nDevice Model                    : \nDevice Attributes               : Reflective, Glossy, Positive, Color\nRendering Intent                : Perceptual\nConnection Space Illuminant     : 0.9642 1 0.82491\nProfile Creator                 : Little CMS\nProfile ID                      : 0\nProfile Description             : GIMP built-in sRGB\nProfile Copyright               : Public Domain\nMedia White Point               : 0.9642 1 0.82491\nChromatic Adaptation            : 1.04788 0.02292 -0.05022 0.02959 0.99048 -0.01707 -0.00925 0.01508 0.75168\nRed Matrix Column               : 0.43604 0.22249 0.01392\nBlue Matrix Column              : 0.14305 0.06061 0.71393\nGreen Matrix Column             : 0.38512 0.7169 0.09706\nRed Tone Reproduction Curve     : (Binary data 32 bytes, use -b option to extract)\nGreen Tone Reproduction Curve   : (Binary data 32 bytes, use -b option to extract)\nBlue Tone Reproduction Curve    : (Binary data 32 bytes, use -b option to extract)\nChromaticity Channels           : 3\nChromaticity Colorant           : Unknown (0)\nChromaticity Channel 1          : 0.64 0.33002\nChromaticity Channel 2          : 0.3 0.60001\nChromaticity Channel 3          : 0.15001 0.06\nDevice Mfg Desc                 : GIMP\nDevice Model Desc               : sRGB\nExif Byte Order                 : Little-endian (Intel, II)\nImage Description               : Created with GIMP\nOrientation                     : Horizontal (normal)\nX Resolution                    : 300\nY Resolution                    : 300\nResolution Unit                 : inches\nSoftware                        : GIMP 2.10.30\nModify Date                     : 2023:05:14 10:06:19\nUser Comment                    : Created with GIMP\nColor Space                     : sRGB\nSubfile Type                    : Reduced-resolution image\nBits Per Sample                 : 8 8 8\nPhotometric Interpretation      : YCbCr\nSamples Per Pixel               : 3\nThumbnail Offset                : 354\nThumbnail Length                : 7019\nImage Size                      : 96x96\nMegapixels                      : 0.009\nThumbnail Image                 : (Binary data 7019 bytes, use -b option to extract)\n'</code></pre>\n<h3>6. Tmux</h3>\n<p>Tmux позволява да разделим терминалния прозорец и да работим на няколко сесии едновременно. За инсталация на пакета:</p>\n<pre class=\"language-bash line-numbers\"><code>apt install tmux</code></pre>\n<p>После, за стартиране на tmux:</p>\n<pre class=\"language-bash line-numbers\"><code>tmux</code></pre>\n<p>Всички клавишни комбинации за tmux започват с Ctrl+B, за да се избегне припокриване с други комбинации. За да разделите прозореца хоризонтално, използвайте <strong><em>\" (Shift+')</em></strong>, и вертикално със <em><strong>% (Shift+5)</strong></em>. За да навигирате между прозорците, използвайте стрелките (не забравяйте Ctrl+B преди това).</p>\n<h3>7. qrencode</h3>\n<p>С qrencode може да генерираме QR кодове от терминала. Може да се инсталира така:</p>\n<pre class=\"language-bash line-numbers\"><code>apt install qrencode</code></pre>\n<p>И е много лесен е за употреба:</p>\n<pre class=\"language-bash line-numbers\"><code># Генериране на QR код \"пробен текст\"\nqrencode \"пробен текст\" -o qr_code.svg</code></pre>\n<figure class=\"post__image\"><span style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\">Резултат:</span><img loading=\"lazy\"  style=\"color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);\" src=\"https://kaloyan-projects.github.io/media/posts/9/qr_code.png\" alt=\"\" width=\"99\" height=\"99\"></figure>\n<h3>8. fzf</h3>\n<p>fzf (fuzzy finder) е много полезен при търсене на файлове. Бръз е, и работи дори да пропуснете някой знак при търсене.</p>\n<pre class=\"language-bash line-numbers\"><code>apt install fzf</code></pre>\n<p>Стартиране:</p>\n<pre class=\"language-bash line-numbers\"><code>fzf</code></pre>\n<h1>Бонус програми</h1>\n<p>Не всички програми трябва да са полезни. Понякога просто искаме да се забавляваме. Има и команди, предназначени точно за това. Ето някои от тях:</p>\n<h3>9. cowsay</h3>\n<p>cowsay изобразява говореща крава. Може да напишете какво да казва.</p>\n<pre class=\"language-bash line-numbers\"><code># Инсталация\napt install cowsay\n\n# Употреба\ncowsay \"Здравей!\"\n\n:'\nРезултат:\n __________\n&lt; Здравей! &gt;\n ----------\n        \\   ^__^\n         \\  (oo)\\_______\n            (__)\\       )\\/\\\n                ||----w |\n                ||     ||\n'</code></pre>\n<p>Но не е задължително да е крава – може да изберете измежду наличните модели, за да видите кои са те използвайте:</p>\n<pre class=\"language-bash line-numbers\"><code>cowsay -l</code></pre>\n<p>Ето един от тях:</p>\n<pre class=\"language-bash line-numbers\"><code>cowsay -f fox \"Лисица!\"\n\n:'\n _________\n&lt; Лисица! &gt;\n ---------\n         \\     ,-.      .-,\n          \\    |-.\\ __ /.-|\n           \\   \\  `    `  /\n                /_     _ \\\n              &lt;  _`q  p _  &gt;\n              &lt;.._=/  \\=_. &gt;\n                 {`\\()/`}`\\\n                 {      }  \\\n                 |{    }    \\\n                 \\  --    .- \\\n                 |-      /    \\\n                 | | | | |     ;\n                 | | |.;.,..__ |\n               .-  ;`         `|\n              /    |           /\n              `-../____,..--- `\n\n'</code></pre>\n<h3>10. oneko</h3>\n<p>Командата oneko призовава коте, което гони мишката (курсора). За да прекратите програмата, натиснете Ctrl+C</p>\n<pre class=\"language-bash line-numbers\"><code># Инсталация\napt install oneko\n\noneko\n\n# Показва куче вместо коте\noneko -dog</code></pre>\n<h3>11. lolcat</h3>\n<p>lolcat оцветява текста в цветовете на дъгата.</p>\n<pre class=\"language-bash line-numbers\"><code># Инсталация\napt install lolcat\n\n# Употреба\necho \"Цветен текст\" | lolcat</code></pre>\n<h3>12. cmatrix</h3>\n<p>cmatrix създава известния ефект от Матрицата, с текст, падащ надолу.</p>\n<pre class=\"language-bash line-numbers\"><code># Инсталация\napt install cmatrix\n\n# Употреба\ncmatrix</code></pre>\n<h3>13. cbonsai</h3>\n<p>cbonsai е генератор на бонсай дръвчета. Позволява да се виждат отделните етапи на растеж.</p>\n<pre class=\"language-bash line-numbers\"><code># Инсталация\napt install cbonsai\n\n# Употреба\ncbonsai\n\n# Покажи растеж (0,002 секунди между всяка стъпка)\ncbonsai -lt 0,002\n\n# Продължавай да генерираш дървета на всеки 2 секунди\ncbonsai -iw 2\n\n:'\nРезултат\n                                &amp;\n                                &amp;&amp; &amp;\n                                  &amp;&amp;&amp;&amp;&amp;&amp;&amp;\n                            &amp;    &amp;&amp;|&amp;&amp;&amp;&amp;\n                              &amp;&amp;&amp;&amp;&amp;\\&amp;&amp;&amp;&amp;&amp;&amp;\n                             &amp;&amp;&amp;&amp;&amp;~\\\\&amp;&amp;&amp;\\\n                          &amp;  &amp;&amp;&amp; &amp;/&amp; /|\\ &amp;\n                           &amp;&amp;&amp;&amp;&amp;&amp;|\\&amp;&amp;|&amp;&amp;&amp;\n                            &amp;&amp;\\&amp;/|&amp;&amp;\\&amp;/~\\_\n                            &amp;&amp;&amp;&amp;|/|/|&amp;/|\\\n                             &amp;&amp;&amp;||/ \\|\\|\n                             &amp;  /~&amp;  /|\\|\\&amp;&amp;\n                                 \\|  |//&amp;\\   /\n                                  /~/_&amp;/&amp;&amp;_&amp;&amp;_/&amp;&amp;&amp;\n                                 /|\\//&amp;&amp;/  &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\n                                 /|\\|//&amp;    &amp;&amp;  &amp;&amp;&amp;\n                                 /~|~/_/ &amp;  &amp;&amp; &amp;&amp; &amp;&amp;\n                                  \\/~/  / &amp;/&amp;&amp;&amp;_&amp;&amp;&amp;\n                                  \\/~|   // &amp;_&amp;&amp;&amp;\n                                    /~|  _/\n                                      /~|\n                                        /~~\n                         :___________./~~~\\.___________:\n                          \\                           / \n                           \\_________________________/ \n                           (_)                     (_)\n'</code></pre>",
            "image": "https://kaloyan-projects.github.io/media/posts/9/post-thumbnail-3.png",
            "author": {
                "name": "Калоян"
            },
            "tags": [
                   "Списък",
                   "Любопитно",
                   "Линукс",
                   "Команди"
            ],
            "date_published": "2024-09-30T12:07:08+03:00",
            "date_modified": "2024-09-30T14:59:56+03:00"
        },
        {
            "id": "https://kaloyan-projects.github.io/post-translation/",
            "url": "https://kaloyan-projects.github.io/post-translation/",
            "title": "Превод на постове",
            "summary": "Много елементи в този сайт са на два езика. Бутони, страници, абзаци…&hellip;",
            "content_html": "<p>Много елементи в този сайт са на два езика. Бутони, страници, абзаци… Превеждам ги по най-лесния начин – пиша ги на български и на английски. Ако няма да добавям повече преводи, мисля че е приемливо да използвам този лесен, но не много красив метод. Ако някой разглежда страницата, ще вижда текст и на двата езика.</p>\n<p>Но при постовете като този не исках да ползвам същия метод. Трябва да разделям българския от английския текст по някакъв начин. Ако просто пиша единия под другия, тогава трябва четящия да търси своя език по-надолу в страницата. Ако ги разделя на две колони, тогава става неприятно за четене, особено на мобилни устройства, където текстът би бил прекалено тесен. Ако направя разтварящи се менюта, където текстът може да се показва и скрива с кликане, е малко по-добре, но пак всичко е на една страница.</p>\n<p>Затова реших да направя два варианта на всеки пост – един на български и един на английски. В началото на им ще има линк, който да праща към другия вариант на поста. Но би било много досадно, ако трябваше ръчно да добавям линк всеки път. За щастие в Publii има опция за добавяне на персонализиран HTML към началото или края на всяка страница или пост. Затова можех просто да отида в <em>Tools and Plugins &gt; Custom HTML &gt; Before every post</em> и да добавя следното:</p>\n<pre class=\"language-html line-numbers\"><code>&lt;p class=\"msg msg--info\" id=\"langlink\"&gt;&lt;a href=\"\"&gt;Натиснете тук&lt;/a&gt;&lt;/p&gt;</code></pre>\n<p>Но не е толкова лесно – все пак линкът е различен за всеки пост. Трябваше да напиша и малко JavaScript, за да задам URL адреса според текущия адрес на страницата.</p>\n<pre class=\"language-html line-numbers\"><code>&lt;script&gt;\n    // Взимаме текущия URL адрес\n    var currentURL = window.location.href;\n   // Станици, чиито адрес завършва с \"-2\" са копия и следователно на английски\n    if(currentURL.slice(-3)==\"-2/\") {\n        // Премахваме \"-2\" от адреса за да отидем на българската страница\n    \tdocument.getElementById(\"langlink\").innerHTML = \n    \"&lt;a href=\\\"\" + currentURL.replace(\"-2/\", \"/\") + \"\\\"&gt;Натиснете тук&lt;/a&gt;, за да видите поста на български.\";\n    } else {\n        // Добавяме \"-2\" към адреса за да отидем на английската страница\n    \tdocument.getElementById(\"langlink\").innerHTML = \"&lt;a href=\\\"\" + currentURL.replace(/.$/, \"\") + \"-2/\" + \"\\\"&gt;Click here&lt;/a&gt; to view this post in English.\";\n    }\n&lt;/script&gt;</code></pre>\n<p>Не е много изпипано, но върши работа. Стига да спазвам същите конвенции за адреса на страниците, би трябвало да няма проблем.</p>",
            "image": "https://kaloyan-projects.github.io/media/posts/7/post-thumbnail-2.png",
            "author": {
                "name": "Калоян"
            },
            "tags": [
                   "Програмиране",
                   "Превод",
                   "Мета"
            ],
            "date_published": "2024-09-29T15:00:00+03:00",
            "date_modified": "2024-09-29T15:47:31+03:00"
        },
        {
            "id": "https://kaloyan-projects.github.io/first-post/",
            "url": "https://kaloyan-projects.github.io/first-post/",
            "title": "Първи пост",
            "summary": "Никога преди не съм правил постове, но този би трябвало да се&hellip;",
            "content_html": "<p>Никога преди не съм правил постове, но този би трябвало да се вижда на началната страница. Още разучавам тънкостите на <a href=\"https://getpublii.com/\">Publii</a> и възможностите при създаване на страници. Смятам тук да си направя портфолио и да качвам мои неща.</p>\n<hr>\n<pre class=\"language-java line-numbers\"><code>public static void main(String args[]) {\n\tSystem.out.println(\"Hello world!\");\n}</code></pre>",
            "image": "https://kaloyan-projects.github.io/media/posts/5/first-post-2.png",
            "author": {
                "name": "Калоян"
            },
            "tags": [
                   "Мета"
            ],
            "date_published": "2024-09-28T18:48:32+03:00",
            "date_modified": "2024-09-29T13:02:22+03:00"
        }
    ]
}
